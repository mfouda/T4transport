% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Wasserstein.R
\name{Wasserstein}
\alias{Wasserstein}
\title{Wasserstein Distance between Empirical Measures}
\usage{
Wasserstein(
  dxy,
  p = 1,
  wx = NULL,
  wy = NULL,
  method = c("lp", "networkflow", "shortsimplex", "revsimplex", "primaldual")
)
}
\arguments{
\item{dxy}{an \eqn{(M\times N)} matrix of distances \eqn{d(x_m,y_n)}.}

\item{p}{an exponent for Wasserstein distance \eqn{\mathcal{W}_p}.}

\item{wx}{a length-\eqn{M} weight vector that sums to 1; if \code{NULL}, it automatically takes uniform weights \code{rep(1/M,M)}.}

\item{wy}{a length-\eqn{N} weight vector that sums to 1; if \code{NULL}, it automatically takes uniform weights \code{rep(1/N,N)}.}

\item{method}{name of an algorithm}
}
\description{
Wasserstein Distance between Empirical Measures
}
\examples{
## create two small datasets from bivariate normal
m = 20
n = 10
X = matrix(rnorm(m*2),ncol=2) # m obs. for X
Y = matrix(rnorm(n*2),ncol=2) # n obs. for Y

## compute cross-distance between X and Y
dXY = array(0,c(m,n))
for (i in 1:m){
  vx = as.vector(X[i,])
  for (j in 1:n){
    vy  = as.vector(Y[j,])
    dXY[i,j] = sqrt(sum((vx-vy)^2))
  }
}

## compute algorithms for W_1 distances
out1 = Wasserstein(dXY, method="lp")
out2 = Wasserstein(dXY, method="networkflow")
out3 = Wasserstein(dXY, method="primaldual")

## visualize
#  show the transport plan and computed distance
opar <- par(no.readonly=TRUE)
par(mfrow=c(1,3))
image(out1$plan,main=paste0("LP:",round(out1$distance,4)))
image(out2$plan,main=paste0("Network Flow:",round(out2$distance,4)))
image(out3$plan,main=paste0("Primal-Dual:",round(out3$distance,4)))
par(opar)

}
