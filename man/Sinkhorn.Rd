% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Sinkhorn.R
\name{Sinkhorn}
\alias{Sinkhorn}
\title{Sinkhorn Distance}
\usage{
Sinkhorn(
  dxy,
  p = 1,
  wx = NULL,
  wy = NULL,
  lambda = 0.1,
  method = c("basic"),
  maxiter = 496,
  abstol = 1e-06
)
}
\description{
Sinkhorn Distance
}
\examples{
## create two small datasets from bivariate normal
m = 20
n = 10
X = matrix(rnorm(m*2),ncol=2) # m obs. for X
Y = matrix(rnorm(n*2),ncol=2) # n obs. for Y

## compute cross-distance between X and Y
dXY = array(0,c(m,n))
for (i in 1:m){
  vx = as.vector(X[i,])
  for (j in 1:n){
    vy  = as.vector(Y[j,])
    dXY[i,j] = sqrt(sum((vx-vy)^2))
  }
}

## use several lambdas and compare with Wasserstein distance
outLP = Wasserstein(dXY, method="lp")
outS1 = Sinkhorn(dXY, lambda=0.01)
outS2 = Sinkhorn(dXY, lambda=0.05)
outS3 = Sinkhorn(dXY, lambda=0.1)

## visualize
#  show the transport plans and computed distance
opar <- par(no.readonly=TRUE)
par(mfrow=c(2,2))
image(outLP$plan,main=paste0("LP:",round(outLP$distance,3)))
image(outS1$plan,main=paste0("lambda=0.01:",round(outS1$distance,3)))
image(outS2$plan,main=paste0("lambda=0.05:",round(outS2$distance,3)))
image(outS3$plan,main=paste0("lambda=0.10:",round(outS3$distance,3)))
par(opar)

\dontrun{
## let's see the effect of regularization parameter 'lambda'
vec.lambda = 10^seq(from=-2,to=0,length.out=100)
vec.dist   = rep(0,100)
for (i in 1:100){
  vec.dist[i] = Sinkhorn(dXY, lambda=vec.lambda[i])$distance
}
opar <- par(no.readonly=TRUE)
plot(vec.lambda, vec.dist, "b", cex=0.5, xlab="lambda",
     ylab="distance", main="Sinkhorn Distances")
abline(h=outLP$distance, lwd=2, col="red")
par(opar)
}

}
